# Story 1.3: mcp-bridge-integration

## Status
Approved

## Story
**As a** system architect,
**I want** existing MCP services accessible to AutoGen agents in the Python backend,
**so that** agents can leverage current Perplexity, fact-checking, and Gayed signal data without reimplementation.

## Foundation Component
**PARALLEL DEVELOPMENT**: Can work simultaneously with Story 1.1b since it bridges existing MCP services to the new Python backend.

## Acceptance Criteria
1. **MCP SERVICE ACCESS**: Python backend can invoke existing MCP services (Perplexity, fact-checking, trader MCP)
2. **GAYED SIGNAL BRIDGE**: AutoGen agents can access current Gayed signal calculations from SignalOrchestrator
3. **MARKET DATA BRIDGE**: EnhancedMarketClient data accessible to AutoGen agents through API bridge
4. **ECONOMIC DATA ACCESS**: FRED API client and economic data pipeline accessible from Python backend
5. **WEB SEARCH BRIDGE**: Existing web-search-service functionality available to AutoGen agents
6. **API COMMUNICATION**: Next.js ↔ Python communication layer for MCP service data
7. **CACHING STRATEGY**: MCP service responses cached to avoid redundant API calls
8. **ERROR HANDLING**: MCP service failures handled gracefully with fallback mechanisms
9. **AUTHENTICATION**: MCP service authentication preserved through API bridge
10. **PERFORMANCE**: MCP bridge optimized for AutoGen conversation timeline requirements

## Tasks / Subtasks
- [ ] Create MCP service bridge (AC: 1, 6)
  - [ ] Design Next.js ↔ Python API communication for MCP services
  - [ ] Create MCP service proxy endpoints in Python backend
- [ ] Bridge Gayed signal data (AC: 2, 3)
  - [ ] Create SignalOrchestrator API bridge
  - [ ] Connect EnhancedMarketClient data to Python backend
- [ ] Bridge economic and web search data (AC: 4, 5)
  - [ ] Create FRED API client bridge
  - [ ] Bridge web-search-service functionality
- [ ] Implement caching and error handling (AC: 7, 8, 9)
  - [ ] Add MCP response caching strategy
  - [ ] Implement graceful error handling and fallbacks
  - [ ] Preserve existing authentication patterns
- [ ] Optimize for AutoGen performance (AC: 10)
  - [ ] Optimize bridge for conversation timeline requirements

## Dev Notes

### MCP Service Bridge Architecture
```typescript
// Next.js MCP Bridge API
// apps/web/src/app/api/mcp-bridge/route.ts
import { perplexityMcp } from '@/lib/mcp/perplexity-client';
import { webSearchService } from '@/lib/fact-check/web-search-service';
import { signalOrchestrator } from '@/domains/trading-signals/engines/orchestrator';

export async function POST(request: Request) {
  const { service, method, params } = await request.json();

  switch (service) {
    case 'perplexity':
      return await handlePerplexityRequest(method, params);
    case 'signals':
      return await handleSignalsRequest(method, params);
    case 'web-search':
      return await handleWebSearchRequest(method, params);
    default:
      return new Response('Unknown service', { status: 400 });
  }
}

async function handleSignalsRequest(method: string, params: any) {
  try {
    const signalData = await signalOrchestrator.getCurrentSignals();
    return Response.json({ success: true, data: signalData });
  } catch (error) {
    return Response.json({ success: false, error: error.message });
  }
}
```

### Python MCP Client
```python
# apps/backend/app/services/mcp_bridge.py
import aiohttp
import asyncio
from typing import Dict, Any, Optional
from app.core.config import settings

class MCPBridgeClient:
    def __init__(self):
        self.base_url = settings.FRONTEND_API_URL
        self.session = None

    async def get_session(self):
        if self.session is None:
            self.session = aiohttp.ClientSession()
        return self.session

    async def call_mcp_service(
        self,
        service: str,
        method: str,
        params: Dict[str, Any],
        timeout: int = 30
    ) -> Dict[str, Any]:
        """Call MCP service through Next.js bridge."""
        session = await self.get_session()

        try:
            async with session.post(
                f"{self.base_url}/api/mcp-bridge",
                json={
                    "service": service,
                    "method": method,
                    "params": params
                },
                timeout=aiohttp.ClientTimeout(total=timeout)
            ) as response:
                result = await response.json()

                if not result.get("success"):
                    raise MCPServiceError(f"MCP service error: {result.get('error')}")

                return result.get("data")

        except asyncio.TimeoutError:
            raise MCPServiceError(f"MCP service timeout: {service}.{method}")
        except Exception as e:
            raise MCPServiceError(f"MCP bridge error: {str(e)}")

    # Specific service methods
    async def get_gayed_signals(self) -> Dict[str, Any]:
        """Get current Gayed signal calculations."""
        return await self.call_mcp_service("signals", "getCurrentSignals", {})

    async def search_perplexity(self, query: str) -> Dict[str, Any]:
        """Search using Perplexity MCP service."""
        return await self.call_mcp_service("perplexity", "search", {"query": query})

    async def search_web(self, query: str, max_results: int = 5) -> Dict[str, Any]:
        """Search web using existing web-search-service."""
        return await self.call_mcp_service(
            "web-search",
            "search",
            {"query": query, "max_results": max_results}
        )

    async def get_economic_data(self, indicator: str) -> Dict[str, Any]:
        """Get economic data from FRED API."""
        return await self.call_mcp_service(
            "economic-data",
            "getIndicator",
            {"indicator": indicator}
        )
```

### AutoGen Agent Integration
```python
# apps/backend/app/agents/financial_analyst.py (Enhanced)
from app.services.mcp_bridge import MCPBridgeClient
from app.agents.base_agent import BaseFinancialAgent

class EnhancedFinancialAnalystAgent(BaseFinancialAgent):
    def __init__(self, model_config: Dict[str, Any]):
        super().__init__(
            name="FinancialAnalyst",
            system_message=self._build_system_message(),
            model_config=model_config
        )
        self.mcp_client = MCPBridgeClient()

    async def analyze_with_signals(self, content: str) -> str:
        """Analyze content with current Gayed signals context."""
        try:
            # Get current signal data through MCP bridge
            signals = await self.mcp_client.get_gayed_signals()

            # Enhance analysis prompt with signal context
            enhanced_prompt = f"""
            Content to analyze: {content}

            Current Gayed Signals:
            - Risk Status: {signals.get('risk_status')}
            - Utilities/SPY: {signals.get('utilities_spy_ratio')}
            - VIX Defensive: {signals.get('vix_defensive')}
            - Signal Confidence: {signals.get('confidence')}

            Provide quantitative analysis incorporating these signals.
            """

            return await self.generate_reply(enhanced_prompt)

        except Exception as e:
            # Fallback to analysis without signals if bridge fails
            return await self.generate_reply(f"Analyze: {content}")

    def _build_system_message(self) -> str:
        return """
        You are a quantitative financial analyst with access to real-time Gayed signals.
        Use specific metrics, historical context, and confidence levels in your analysis.
        Reference current signal states and provide professional advisory insights.
        """
```

### Caching Strategy
```python
# apps/backend/app/services/mcp_cache.py
import asyncio
from typing import Dict, Any, Optional
import json
import hashlib
from datetime import datetime, timedelta

class MCPCacheManager:
    def __init__(self, default_ttl: int = 300):  # 5 minutes default
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.default_ttl = default_ttl

    def _generate_key(self, service: str, method: str, params: Dict) -> str:
        """Generate cache key from service call parameters."""
        content = f"{service}.{method}.{json.dumps(params, sort_keys=True)}"
        return hashlib.md5(content.encode()).hexdigest()

    async def get(
        self,
        service: str,
        method: str,
        params: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Get cached MCP service response."""
        key = self._generate_key(service, method, params)
        cached_item = self.cache.get(key)

        if cached_item:
            if datetime.now() < cached_item["expires_at"]:
                return cached_item["data"]
            else:
                # Clean up expired item
                del self.cache[key]

        return None

    async def set(
        self,
        service: str,
        method: str,
        params: Dict[str, Any],
        data: Dict[str, Any],
        ttl: Optional[int] = None
    ):
        """Cache MCP service response."""
        key = self._generate_key(service, method, params)
        expires_at = datetime.now() + timedelta(seconds=ttl or self.default_ttl)

        self.cache[key] = {
            "data": data,
            "expires_at": expires_at,
            "created_at": datetime.now()
        }

# Integration with MCPBridgeClient
class CachedMCPBridgeClient(MCPBridgeClient):
    def __init__(self):
        super().__init__()
        self.cache = MCPCacheManager()

    async def call_mcp_service(
        self,
        service: str,
        method: str,
        params: Dict[str, Any],
        timeout: int = 30,
        use_cache: bool = True
    ) -> Dict[str, Any]:
        # Check cache first
        if use_cache:
            cached_result = await self.cache.get(service, method, params)
            if cached_result:
                return cached_result

        # Call service if not cached
        result = await super().call_mcp_service(service, method, params, timeout)

        # Cache the result
        if use_cache:
            await self.cache.set(service, method, params, result)

        return result
```

### Key Constraints
- **PRESERVE EXISTING SERVICES**: Must not modify existing MCP implementations
- **AUTHENTICATION BRIDGE**: Must preserve existing Clerk authentication patterns
- **PERFORMANCE**: MCP bridge must not add significant latency to AutoGen conversations
- **ERROR HANDLING**: Graceful fallbacks when MCP services unavailable
- **CACHING**: Intelligent caching to avoid redundant API calls during conversations

### Testing Framework
```python
# apps/backend/tests/test_mcp_bridge.py
import pytest
from unittest.mock import Mock, patch
from app.services.mcp_bridge import MCPBridgeClient

@pytest.fixture
def mock_mcp_client():
    return MCPBridgeClient()

@pytest.mark.asyncio
async def test_gayed_signals_bridge(mock_mcp_client):
    """Test Gayed signals accessible through MCP bridge."""
    with patch('aiohttp.ClientSession.post') as mock_post:
        mock_response = Mock()
        mock_response.json.return_value = {
            "success": True,
            "data": {"risk_status": "Risk-Off", "confidence": 0.85}
        }
        mock_post.return_value.__aenter__.return_value = mock_response

        signals = await mock_mcp_client.get_gayed_signals()
        assert signals["risk_status"] == "Risk-Off"
        assert signals["confidence"] == 0.85

@pytest.mark.asyncio
async def test_mcp_bridge_error_handling(mock_mcp_client):
    """Test graceful error handling when MCP services fail."""
    with patch('aiohttp.ClientSession.post', side_effect=Exception("Network error")):
        with pytest.raises(MCPServiceError):
            await mock_mcp_client.get_gayed_signals()
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-28 | 1.0 | MCP bridge integration extracted from 1.1 for parallel development | Sarah (PO) |

## Dev Agent Record
_(This section is owned by dev-agent and can only be modified by dev-agent)_

## QA Results
_(This section is owned by qa-agent and can only be modified by qa-agent)_