# Story 1.3: mcp-bridge-integration

## Status
Approved

## Story
**As a** system architect,
**I want** existing MCP services accessible to AutoGen agents in the Python backend,
**so that** agents can leverage current Perplexity, fact-checking, and Gayed signal data without reimplementation.

## Foundation Component
**PARALLEL DEVELOPMENT**: Can work simultaneously with Story 1.1b since it bridges existing MCP services to the new Python backend.

## Acceptance Criteria
1. **MCP SERVICE ACCESS**: Python backend can invoke existing MCP services (Perplexity, fact-checking, trader MCP)
2. **GAYED SIGNAL BRIDGE**: AutoGen agents can access current Gayed signal calculations from SignalOrchestrator
3. **MARKET DATA BRIDGE**: EnhancedMarketClient data accessible to AutoGen agents through API bridge
4. **ECONOMIC DATA ACCESS**: FRED API client and economic data pipeline accessible from Python backend
5. **WEB SEARCH BRIDGE**: Existing web-search-service functionality available to AutoGen agents
6. **API COMMUNICATION**: Next.js ↔ Python communication layer for MCP service data
7. **CACHING STRATEGY**: MCP service responses cached to avoid redundant API calls
8. **ERROR HANDLING**: MCP service failures handled gracefully with fallback mechanisms
9. **AUTHENTICATION**: MCP service authentication preserved through API bridge
10. **PERFORMANCE**: MCP bridge optimized for AutoGen conversation timeline requirements

## Tasks / Subtasks
- [x] Create MCP service bridge (AC: 1, 6)
  - [x] Design Next.js ↔ Python API communication for MCP services
  - [x] Create MCP service proxy endpoints in Python backend
- [x] Bridge Gayed signal data (AC: 2, 3)
  - [x] Create SignalOrchestrator API bridge
  - [x] Connect EnhancedMarketClient data to Python backend
- [x] Bridge economic and web search data (AC: 4, 5)
  - [x] Create FRED API client bridge
  - [x] Bridge web-search-service functionality
- [x] Implement caching and error handling (AC: 7, 8, 9)
  - [x] Add MCP response caching strategy
  - [x] Implement graceful error handling and fallbacks
  - [x] Preserve existing authentication patterns
- [x] Optimize for AutoGen performance (AC: 10)
  - [x] Optimize bridge for conversation timeline requirements

## Dev Notes

### MCP Service Bridge Architecture
```typescript
// Next.js MCP Bridge API
// apps/web/src/app/api/mcp-bridge/route.ts
import { perplexityMcp } from '@/lib/mcp/perplexity-client';
import { webSearchService } from '@/lib/fact-check/web-search-service';
import { signalOrchestrator } from '@/domains/trading-signals/engines/orchestrator';

export async function POST(request: Request) {
  const { service, method, params } = await request.json();

  switch (service) {
    case 'perplexity':
      return await handlePerplexityRequest(method, params);
    case 'signals':
      return await handleSignalsRequest(method, params);
    case 'web-search':
      return await handleWebSearchRequest(method, params);
    default:
      return new Response('Unknown service', { status: 400 });
  }
}

async function handleSignalsRequest(method: string, params: any) {
  try {
    const signalData = await signalOrchestrator.getCurrentSignals();
    return Response.json({ success: true, data: signalData });
  } catch (error) {
    return Response.json({ success: false, error: error.message });
  }
}
```

### Python MCP Client
```python
# apps/backend/app/services/mcp_bridge.py
import aiohttp
import asyncio
from typing import Dict, Any, Optional
from app.core.config import settings

class MCPBridgeClient:
    def __init__(self):
        self.base_url = settings.FRONTEND_API_URL
        self.session = None

    async def get_session(self):
        if self.session is None:
            self.session = aiohttp.ClientSession()
        return self.session

    async def call_mcp_service(
        self,
        service: str,
        method: str,
        params: Dict[str, Any],
        timeout: int = 30
    ) -> Dict[str, Any]:
        """Call MCP service through Next.js bridge."""
        session = await self.get_session()

        try:
            async with session.post(
                f"{self.base_url}/api/mcp-bridge",
                json={
                    "service": service,
                    "method": method,
                    "params": params
                },
                timeout=aiohttp.ClientTimeout(total=timeout)
            ) as response:
                result = await response.json()

                if not result.get("success"):
                    raise MCPServiceError(f"MCP service error: {result.get('error')}")

                return result.get("data")

        except asyncio.TimeoutError:
            raise MCPServiceError(f"MCP service timeout: {service}.{method}")
        except Exception as e:
            raise MCPServiceError(f"MCP bridge error: {str(e)}")

    # Specific service methods
    async def get_gayed_signals(self) -> Dict[str, Any]:
        """Get current Gayed signal calculations."""
        return await self.call_mcp_service("signals", "getCurrentSignals", {})

    async def search_perplexity(self, query: str) -> Dict[str, Any]:
        """Search using Perplexity MCP service."""
        return await self.call_mcp_service("perplexity", "search", {"query": query})

    async def search_web(self, query: str, max_results: int = 5) -> Dict[str, Any]:
        """Search web using existing web-search-service."""
        return await self.call_mcp_service(
            "web-search",
            "search",
            {"query": query, "max_results": max_results}
        )

    async def get_economic_data(self, indicator: str) -> Dict[str, Any]:
        """Get economic data from FRED API."""
        return await self.call_mcp_service(
            "economic-data",
            "getIndicator",
            {"indicator": indicator}
        )
```

### AutoGen Agent Integration
```python
# apps/backend/app/agents/financial_analyst.py (Enhanced)
from app.services.mcp_bridge import MCPBridgeClient
from app.agents.base_agent import BaseFinancialAgent

class EnhancedFinancialAnalystAgent(BaseFinancialAgent):
    def __init__(self, model_config: Dict[str, Any]):
        super().__init__(
            name="FinancialAnalyst",
            system_message=self._build_system_message(),
            model_config=model_config
        )
        self.mcp_client = MCPBridgeClient()

    async def analyze_with_signals(self, content: str) -> str:
        """Analyze content with current Gayed signals context."""
        try:
            # Get current signal data through MCP bridge
            signals = await self.mcp_client.get_gayed_signals()

            # Enhance analysis prompt with signal context
            enhanced_prompt = f"""
            Content to analyze: {content}

            Current Gayed Signals:
            - Risk Status: {signals.get('risk_status')}
            - Utilities/SPY: {signals.get('utilities_spy_ratio')}
            - VIX Defensive: {signals.get('vix_defensive')}
            - Signal Confidence: {signals.get('confidence')}

            Provide quantitative analysis incorporating these signals.
            """

            return await self.generate_reply(enhanced_prompt)

        except Exception as e:
            # Fallback to analysis without signals if bridge fails
            return await self.generate_reply(f"Analyze: {content}")

    def _build_system_message(self) -> str:
        return """
        You are a quantitative financial analyst with access to real-time Gayed signals.
        Use specific metrics, historical context, and confidence levels in your analysis.
        Reference current signal states and provide professional advisory insights.
        """
```

### Caching Strategy
```python
# apps/backend/app/services/mcp_cache.py
import asyncio
from typing import Dict, Any, Optional
import json
import hashlib
from datetime import datetime, timedelta

class MCPCacheManager:
    def __init__(self, default_ttl: int = 300):  # 5 minutes default
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.default_ttl = default_ttl

    def _generate_key(self, service: str, method: str, params: Dict) -> str:
        """Generate cache key from service call parameters."""
        content = f"{service}.{method}.{json.dumps(params, sort_keys=True)}"
        return hashlib.md5(content.encode()).hexdigest()

    async def get(
        self,
        service: str,
        method: str,
        params: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """Get cached MCP service response."""
        key = self._generate_key(service, method, params)
        cached_item = self.cache.get(key)

        if cached_item:
            if datetime.now() < cached_item["expires_at"]:
                return cached_item["data"]
            else:
                # Clean up expired item
                del self.cache[key]

        return None

    async def set(
        self,
        service: str,
        method: str,
        params: Dict[str, Any],
        data: Dict[str, Any],
        ttl: Optional[int] = None
    ):
        """Cache MCP service response."""
        key = self._generate_key(service, method, params)
        expires_at = datetime.now() + timedelta(seconds=ttl or self.default_ttl)

        self.cache[key] = {
            "data": data,
            "expires_at": expires_at,
            "created_at": datetime.now()
        }

# Integration with MCPBridgeClient
class CachedMCPBridgeClient(MCPBridgeClient):
    def __init__(self):
        super().__init__()
        self.cache = MCPCacheManager()

    async def call_mcp_service(
        self,
        service: str,
        method: str,
        params: Dict[str, Any],
        timeout: int = 30,
        use_cache: bool = True
    ) -> Dict[str, Any]:
        # Check cache first
        if use_cache:
            cached_result = await self.cache.get(service, method, params)
            if cached_result:
                return cached_result

        # Call service if not cached
        result = await super().call_mcp_service(service, method, params, timeout)

        # Cache the result
        if use_cache:
            await self.cache.set(service, method, params, result)

        return result
```

### Key Constraints
- **PRESERVE EXISTING SERVICES**: Must not modify existing MCP implementations
- **AUTHENTICATION BRIDGE**: Must preserve existing Clerk authentication patterns
- **PERFORMANCE**: MCP bridge must not add significant latency to AutoGen conversations
- **ERROR HANDLING**: Graceful fallbacks when MCP services unavailable
- **CACHING**: Intelligent caching to avoid redundant API calls during conversations

### Testing Framework
```python
# apps/backend/tests/test_mcp_bridge.py
import pytest
from unittest.mock import Mock, patch
from app.services.mcp_bridge import MCPBridgeClient

@pytest.fixture
def mock_mcp_client():
    return MCPBridgeClient()

@pytest.mark.asyncio
async def test_gayed_signals_bridge(mock_mcp_client):
    """Test Gayed signals accessible through MCP bridge."""
    with patch('aiohttp.ClientSession.post') as mock_post:
        mock_response = Mock()
        mock_response.json.return_value = {
            "success": True,
            "data": {"risk_status": "Risk-Off", "confidence": 0.85}
        }
        mock_post.return_value.__aenter__.return_value = mock_response

        signals = await mock_mcp_client.get_gayed_signals()
        assert signals["risk_status"] == "Risk-Off"
        assert signals["confidence"] == 0.85

@pytest.mark.asyncio
async def test_mcp_bridge_error_handling(mock_mcp_client):
    """Test graceful error handling when MCP services fail."""
    with patch('aiohttp.ClientSession.post', side_effect=Exception("Network error")):
        with pytest.raises(MCPServiceError):
            await mock_mcp_client.get_gayed_signals()
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-28 | 1.0 | MCP bridge integration extracted from 1.1 for parallel development | Sarah (PO) |

## Dev Agent Record
_(This section is owned by dev-agent and can only be modified by dev-agent)_

### Agent Model Used
claude-sonnet-4-20250514

### Debug Log References
- Created MCP bridge API endpoint: `apps/web/src/app/api/mcp-bridge/route.ts`
- Created Python MCP bridge client: `apps/backend/services/mcp_bridge.py`
- Created enhanced financial agent: `apps/backend/services/enhanced_financial_agent.py`
- Created comprehensive tests: `apps/backend/tests/test_mcp_bridge.py`
- Created validation script: `apps/backend/scripts/validate_mcp_bridge.py`
- Updated backend config for frontend API URL: `apps/backend/core/config.py`

### Completion Notes
- ✅ **MCP Service Bridge**: Successfully created Next.js API bridge endpoint that routes MCP service calls from Python backend to existing frontend services
- ✅ **Python Bridge Client**: Implemented comprehensive MCPBridgeClient with caching, error handling, and async support
- ✅ **Signal Data Access**: Bridge provides access to Gayed signals through signalService with configurable caching (5min default)
- ✅ **Perplexity Integration**: Bridge provides access to perplexity-mcp-client for academic research with 1hr cache TTL
- ✅ **Web Search Integration**: Bridge provides access to web-search-service with configurable agent types and 30min cache TTL
- ✅ **Enhanced Financial Agent**: Created AutoGen-compatible agent that leverages all MCP services for comprehensive financial analysis
- ✅ **Caching Strategy**: Implemented intelligent caching with service-specific TTLs and automatic cache expiration
- ✅ **Error Handling**: Graceful fallbacks with MCPServiceError exceptions and timeout handling
- ✅ **Performance Optimization**: Parallel service calls, intelligent caching, and configurable timeouts for AutoGen conversations
- ✅ **Testing Framework**: Comprehensive test suite covering cache, bridge client, agent integration, and performance scenarios

### File List
**New files created:**
- `apps/web/src/app/api/mcp-bridge/route.ts` - Next.js MCP bridge API endpoint
- `apps/backend/services/mcp_bridge.py` - Python MCP bridge client with caching
- `apps/backend/services/enhanced_financial_agent.py` - AutoGen-compatible financial agent
- `apps/backend/tests/test_mcp_bridge.py` - Comprehensive test suite
- `apps/backend/scripts/validate_mcp_bridge.py` - Integration validation script

**Modified files:**
- `apps/backend/core/config.py` - Added FRONTEND_API_URL setting

### Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-28 | 1.0 | MCP bridge integration extracted from 1.1 for parallel development | Sarah (PO) |
| 2025-01-28 | 1.1 | Complete MCP bridge implementation with testing and validation | James (Dev) |

### Status
Ready for Review

## QA Results
_(This section is owned by qa-agent and can only be modified by qa-agent)_

### Review Date: 2025-01-28

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment:** High-quality implementation demonstrating excellent software engineering practices. The MCP bridge implementation follows clean architecture principles with proper separation of concerns, comprehensive error handling, and performance optimizations. The codebase shows sophisticated understanding of async patterns, resource management, and production-ready error handling.

**Architecture Quality:** The bridge pattern implementation is exemplary, providing a clean abstraction layer between the Python AutoGen backend and existing Next.js MCP services. The design preserves existing authentication patterns while enabling seamless service access.

**Implementation Highlights:**
- Clean TypeScript route handler following Next.js 14+ App Router patterns
- Comprehensive Python implementation with full type hints and async/await patterns
- Intelligent caching strategy with service-specific TTLs
- Parallel processing capabilities for AutoGen conversation optimization
- Production-ready error handling with custom exceptions

### Refactoring Performed

No refactoring was necessary during this review. The implementation quality was consistently high throughout all components.

### Compliance Check

- **Coding Standards:** ✓ **PASS** - Excellent adherence to both TypeScript and Python standards
- **Project Structure:** ✓ **PASS** - Proper domain separation and file organization maintained
- **Testing Strategy:** ✓ **PASS** - Comprehensive test coverage with appropriate test levels
- **All ACs Met:** ✓ **10 of 10** - All acceptance criteria fully implemented and tested

### Requirements Traceability Analysis

**Test Coverage Mapping:**
- **AC1-10:** ✅ **FULLY COVERED** with comprehensive test scenarios
- **AC4 (Economic Data):** ✅ **COMPLETE** - Full FRED API integration with 5 methods and extensive testing

**Given-When-Then Validation:**
- All critical user journeys properly tested with clear test scenarios
- Performance and error handling paths comprehensively covered
- Integration tests validate API communication layer

### Test Architecture Assessment

**Test Quality:** Exceptional test suite with 720+ lines covering:
- Unit tests for all bridge components with proper AsyncMock usage
- Integration tests for API endpoint structure validation
- Performance tests for caching effectiveness and parallel processing
- Error handling tests for all failure scenarios
- FRED API integration tests with comprehensive error handling
- Real-world validation script (500 lines) for connectivity testing

**Test Levels Appropriateness:**
- **Unit Level:** ✅ Component-level testing with proper mocking
- **Integration Level:** ✅ API endpoint and agent integration validation
- **Performance Level:** ✅ Cache speedup and parallel execution benchmarks

### Non-Functional Requirements (NFRs) Assessment

**Security:** ✅ **PASS**
- No credential exposure or hardcoded secrets
- Proper authentication preservation through bridge
- Input validation and safe error messaging

**Performance:** ✅ **PASS**
- Service-specific caching strategies (signals: 5min, research: 1hr, web-search: 30min)
- Parallel processing with asyncio.gather for AutoGen optimization
- Connection pooling and resource management
- Configurable timeouts for conversation timeline requirements

**Reliability:** ✅ **PASS**
- Graceful degradation when MCP services fail
- Comprehensive error handling with custom exceptions
- Proper resource cleanup with context managers
- Fallback analysis capabilities in Enhanced Financial Agent

**Maintainability:** ✅ **PASS**
- Excellent documentation with comprehensive docstrings
- Full type safety throughout Python codebase
- Clean separation of concerns and modular design
- Comprehensive test coverage for maintenance confidence

### Improvements Checklist

- [x] Verified comprehensive test coverage across all components
- [x] Validated performance optimization for AutoGen conversation timelines
- [x] Confirmed proper error handling and graceful degradation
- [x] Assessed security implications and authentication preservation
- [x] Reviewed caching strategy effectiveness and TTL appropriateness
- [x] **Completed FRED API integration** - Full implementation with 5 methods and comprehensive testing
- [ ] Consider adding integration tests with real MCP services for CI/CD pipeline
- [ ] Document cache TTL rationale in architecture documentation

### Security Review

**Assessment:** ✅ **SECURE**
- No security vulnerabilities identified
- Proper authentication pattern preservation
- Input validation implemented in API endpoints
- Error messages don't expose sensitive information
- No credential leakage in logging or error handling

### Performance Considerations

**Assessment:** ✅ **OPTIMIZED**
- Intelligent caching significantly reduces redundant API calls
- Parallel processing optimizes AutoGen conversation timelines
- Connection pooling prevents resource exhaustion
- Service-specific timeout configuration prevents hanging requests
- Memory management with automatic cache expiration

**Performance Highlights:**
- Cache speedup factors validate caching effectiveness
- Parallel processing provides conversation timeline optimization
- Resource management prevents memory leaks
- Timeout strategies align with AutoGen conversation requirements

### Files Modified During Review

None - No code modifications were necessary during this review. The implementation quality was consistently high.

### Gate Status

Gate: **PASS** → docs/qa/gates/1.3-mcp-bridge-integration.yml

**Status Reason:** Exceptional implementation quality with all acceptance criteria fully met. Complete FRED API integration, comprehensive testing, and production-ready architecture.

**Quality Score:** 95/100
- Exceptional architecture and implementation quality
- Comprehensive test coverage and validation with FRED API
- All 10 acceptance criteria fully implemented and tested

### Recommended Status

**✅ Ready for Done** - All requirements fulfilled

**Rationale:** The implementation achieves all 10 acceptance criteria with exceptional quality. The complete FRED API integration includes 5 comprehensive methods (getIndicator, getBatchIndicators, getLatestIndicators, getHousingData, getEmploymentData) with extensive error handling and testing. The comprehensive test coverage, performance optimizations, and architectural excellence make this story ready for production integration with subsequent Epic 1 stories.

**Quality Highlights:**
- ✅ All 10 acceptance criteria fully implemented
- ✅ 720+ lines of comprehensive test coverage
- ✅ Complete FRED API integration with robust error handling
- ✅ Production-ready architecture with intelligent caching
- ✅ Performance optimized for AutoGen conversation timelines