# Story 2.6: live-conversation-display

## Status
Draft

## Story
**As a** financial professional,
**I want** to watch AutoGen agent conversations develop in real-time,
**so that** I can follow the transparent reasoning process as agents debate financial content.

## Acceptance Criteria
1. Live conversation component built using existing UI patterns and component structure
2. Real-time message display maintains existing responsive design and mobile optimization
3. Agent conversation UI integrates with current theme system and professional styling
4. Conversation display preserves existing accessibility standards and user experience patterns
5. Live streaming component handles connection errors using existing error boundary patterns
6. Agent message formatting consistent with existing dashboard typography and spacing
7. Conversation scrolling and user interaction follows existing dashboard interaction patterns
8. Real-time updates maintain existing performance standards and smooth user experience
9. Agent conversation display integrates with existing loading states and progress indicators
10. Live conversation component respects existing user preferences and dashboard layout

## Tasks / Subtasks
- [ ] Build live conversation component (AC: 1, 3)
  - [ ] Create component using existing UI patterns
  - [ ] Integrate with current theme system and styling
- [ ] Implement real-time display (AC: 2, 6)
  - [ ] Maintain responsive design and mobile optimization
  - [ ] Format agent messages with existing typography
- [ ] Add interaction and scrolling (AC: 4, 7)
  - [ ] Preserve accessibility standards
  - [ ] Follow existing dashboard interaction patterns
- [ ] Handle errors and performance (AC: 5, 8)
  - [ ] Use existing error boundary patterns
  - [ ] Maintain performance standards for real-time updates
- [ ] Integrate with existing systems (AC: 9, 10)
  - [ ] Connect with loading states and progress indicators
  - [ ] Respect user preferences and dashboard layout

## Dev Notes

### **CRITICAL IMPLEMENTATION BLOCKERS**
‚ö†Ô∏è **STORY DEPENDENCY**: Requires Epic 1.8 (Multi-Agent Conversation) completion for AutoGen conversation data
- Epic 1.8: Multi-agent conversation orchestrator - **STATUS: Approved** ‚úÖ
- Epic 1.2: WebSocket infrastructure - **STATUS: Approved** ‚úÖ

### Relevant Source Tree Info
- **VERIFIED**: `/src/components/layout/` - Existing dashboard component patterns ‚úÖ
- **VERIFIED**: `/src/app/globals.css` - Current theme system and professional styling ‚úÖ
- **VERIFIED**: `/src/components/ui/` - Dashboard typography and spacing standards ‚úÖ
- **VERIFIED**: `/src/lib/error-boundary/` - Error boundary patterns and accessibility standards ‚úÖ

### Live Conversation UI Technical Implementation
```typescript
// apps/web/src/components/agents/LiveConversationDisplay.tsx
import React, { useState, useEffect, useRef } from 'react';
import { AgentMessage, ConversationStatus } from '@/types/agents';
import { useWebSocket } from '@/hooks/useWebSocket';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';

interface LiveConversationDisplayProps {
  sessionId: string;
  onConversationComplete?: (result: ConversationResult) => void;
}

export function LiveConversationDisplay({
  sessionId,
  onConversationComplete
}: LiveConversationDisplayProps) {
  const [messages, setMessages] = useState<AgentMessage[]>([]);
  const [status, setStatus] = useState<ConversationStatus>('initializing');
  const scrollRef = useRef<HTMLDivElement>(null);

  // WebSocket connection for real-time updates
  const { socket, isConnected } = useWebSocket(`/api/conversations/${sessionId}/stream`);

  useEffect(() => {
    if (!socket) return;

    socket.on('agent-message', (message: AgentMessage) => {
      setMessages(prev => [...prev, message]);
      // Auto-scroll to latest message
      setTimeout(() => {
        scrollRef.current?.scrollTo({
          top: scrollRef.current.scrollHeight,
          behavior: 'smooth'
        });
      }, 100);
    });

    socket.on('conversation-status', (newStatus: ConversationStatus) => {
      setStatus(newStatus);
    });

    socket.on('conversation-complete', (result: ConversationResult) => {
      setStatus('completed');
      onConversationComplete?.(result);
    });

    return () => {
      socket.off('agent-message');
      socket.off('conversation-status');
      socket.off('conversation-complete');
    };
  }, [socket, onConversationComplete]);

  return (
    <Card className="flex flex-col h-[600px] max-h-[600px]">
      <CardHeader className="flex-shrink-0 pb-3">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold">Live Agent Conversation</h3>
          <ConversationStatusBadge status={status} isConnected={isConnected} />
        </div>
      </CardHeader>

      <CardContent className="flex-1 overflow-hidden p-0">
        <ScrollArea ref={scrollRef} className="h-full px-4">
          <div className="space-y-4 pb-4">
            {messages.map((message, index) => (
              <AgentMessageBubble
                key={`${message.agent}-${index}`}
                message={message}
                isLatest={index === messages.length - 1}
              />
            ))}
            {status === 'active' && <TypingIndicator />}
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  );
}

// Agent message component with professional styling
function AgentMessageBubble({
  message,
  isLatest
}: {
  message: AgentMessage;
  isLatest: boolean;
}) {
  const agentConfig = {
    'FinancialAnalyst': {
      color: 'bg-blue-50 border-blue-200',
      icon: 'üìä',
      name: 'Financial Analyst'
    },
    'MarketContext': {
      color: 'bg-green-50 border-green-200',
      icon: 'üåç',
      name: 'Market Context'
    },
    'RiskChallenger': {
      color: 'bg-amber-50 border-amber-200',
      icon: '‚ö†Ô∏è',
      name: 'Risk Challenger'
    }
  };

  const config = agentConfig[message.agent] || {
    color: 'bg-gray-50 border-gray-200',
    icon: 'ü§ñ',
    name: message.agent
  };

  return (
    <div className={`border rounded-lg p-4 ${config.color} ${isLatest ? 'ring-2 ring-primary/20' : ''}`}>
      <div className="flex items-center gap-2 mb-2">
        <span className="text-lg">{config.icon}</span>
        <h4 className="font-medium text-sm">{config.name}</h4>
        <Badge variant="secondary" className="text-xs">
          {new Date(message.timestamp).toLocaleTimeString()}
        </Badge>
      </div>
      <div className="text-sm text-gray-700 leading-relaxed whitespace-pre-wrap">
        {message.content}
      </div>
      {message.confidence && (
        <div className="mt-2 text-xs text-gray-500">
          Confidence: {Math.round(message.confidence * 100)}%
        </div>
      )}
    </div>
  );
}

// Connection and status indicators
function ConversationStatusBadge({
  status,
  isConnected
}: {
  status: ConversationStatus;
  isConnected: boolean;
}) {
  if (!isConnected) {
    return <Badge variant="destructive">Disconnected</Badge>;
  }

  const statusConfig = {
    'initializing': { label: 'Initializing', variant: 'secondary' as const },
    'active': { label: 'Live Conversation', variant: 'default' as const },
    'completed': { label: 'Complete', variant: 'success' as const },
    'error': { label: 'Error', variant: 'destructive' as const }
  };

  const config = statusConfig[status] || statusConfig.initializing;

  return <Badge variant={config.variant}>{config.label}</Badge>;
}

function TypingIndicator() {
  return (
    <div className="flex items-center gap-2 p-4 bg-gray-50 rounded-lg border-2 border-dashed border-gray-200">
      <div className="flex space-x-1">
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce [animation-delay:-0.3s]"></div>
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce [animation-delay:-0.15s]"></div>
        <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
      </div>
      <span className="text-sm text-gray-500">Agents are discussing...</span>
    </div>
  );
}
```

### WebSocket Integration Architecture
```typescript
// apps/web/src/hooks/useWebSocket.ts
import { useEffect, useState, useRef } from 'react';
import { io, Socket } from 'socket.io-client';

export function useWebSocket(endpoint: string) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const reconnectAttempts = useRef(0);
  const maxReconnectAttempts = 5;

  useEffect(() => {
    const socketInstance = io(endpoint, {
      transports: ['websocket', 'polling'],
      timeout: 20000,
      forceNew: true
    });

    socketInstance.on('connect', () => {
      setIsConnected(true);
      reconnectAttempts.current = 0;
    });

    socketInstance.on('disconnect', () => {
      setIsConnected(false);
    });

    socketInstance.on('connect_error', () => {
      reconnectAttempts.current++;
      if (reconnectAttempts.current > maxReconnectAttempts) {
        socketInstance.disconnect();
      }
    });

    setSocket(socketInstance);

    return () => {
      socketInstance.disconnect();
    };
  }, [endpoint]);

  return { socket, isConnected };
}
```

### Performance & UX Specifications
- **Real-time Latency**: <200ms for message display
- **Smooth Scrolling**: Auto-scroll to latest messages with smooth animation
- **Memory Management**: Limit displayed messages to 50 most recent
- **Responsive Design**: Full functionality on mobile/tablet/desktop
- **Error Recovery**: Automatic reconnection with exponential backoff

### Key Constraints
- Must use existing UI component library (`/src/components/ui/`)
- WebSocket connections limited to 5 concurrent per user
- Message history limited to current conversation only
- Auto-scroll behavior respects user manual scrolling
- Professional financial services styling maintained throughout

### Testing
**Comprehensive Testing Framework:**

**Unit Tests:**
```typescript
// apps/web/__tests__/components/LiveConversationDisplay.test.tsx
import { render, screen, waitFor, act } from '@testing-library/react';
import { LiveConversationDisplay } from '@/components/agents/LiveConversationDisplay';
import { useWebSocket } from '@/hooks/useWebSocket';

jest.mock('@/hooks/useWebSocket');

describe('LiveConversationDisplay', () => {
  const mockUseWebSocket = useWebSocket as jest.MockedFunction<typeof useWebSocket>;

  beforeEach(() => {
    mockUseWebSocket.mockReturnValue({
      socket: mockSocket,
      isConnected: true,
    });
  });

  test('displays real-time agent messages', async () => {
    render(<LiveConversationDisplay sessionId="test-session" />);

    // Simulate WebSocket message
    act(() => {
      mockSocket.emit('agent-message', {
        agent: 'FinancialAnalyst',
        content: 'Market analysis shows bullish signals',
        timestamp: Date.now(),
        confidence: 0.85
      });
    });

    await waitFor(() => {
      expect(screen.getByText('Market analysis shows bullish signals')).toBeInTheDocument();
      expect(screen.getByText('Financial Analyst')).toBeInTheDocument();
      expect(screen.getByText('Confidence: 85%')).toBeInTheDocument();
    });
  });

  test('handles connection errors gracefully', async () => {
    mockUseWebSocket.mockReturnValue({
      socket: null,
      isConnected: false,
    });

    render(<LiveConversationDisplay sessionId="test-session" />);

    expect(screen.getByText('Disconnected')).toBeInTheDocument();
  });
});
```

**Integration Tests:**
- Real-time WebSocket message flow with mock AutoGen agents
- Dashboard layout integration with conversation display
- State synchronization with conversation store
- Theme system and responsive design compatibility

**Performance Tests:**
- Memory usage with 100+ messages (should stay under 200MB)
- WebSocket message throughput (>50 messages/second)
- Auto-scroll performance with rapid message updates
- Component re-render optimization (max 5 renders per message)

**Accessibility Tests:**
- Screen reader compatibility for conversation messages
- Keyboard navigation for conversation controls
- High contrast mode support for agent message bubbles
- ARIA labels for conversation status indicators

**Error Handling Tests:**
- WebSocket disconnection and reconnection scenarios
- Invalid message format handling
- Network timeout and retry mechanisms
- Large message content (>5000 characters) display

**Cross-browser Compatibility:**
- Chrome/Firefox/Safari WebSocket implementation differences
- Mobile browser conversation display optimization
- Touch interaction testing on tablet devices

**End-to-End Tests:**
```typescript
// apps/web/e2e/conversation-display.spec.ts
import { test, expect } from '@playwright/test';

test('displays live agent conversation', async ({ page }) => {
  await page.goto('/dashboard');

  // Start conversation
  await page.click('[data-testid="start-conversation"]');

  // Wait for conversation to appear
  await expect(page.locator('[data-testid="conversation-display"]')).toBeVisible();

  // Verify agent messages appear
  await expect(page.locator('[data-testid="agent-message"]').first()).toBeVisible();

  // Test auto-scroll
  const conversationArea = page.locator('[data-testid="conversation-area"]');
  const scrollPosition = await conversationArea.evaluate(el => el.scrollTop);

  // New message should trigger auto-scroll
  await page.evaluate(() => {
    window.mockSocket.emit('agent-message', {
      agent: 'RiskChallenger',
      content: 'Testing auto-scroll functionality',
      timestamp: Date.now()
    });
  });

  await expect(conversationArea).toHaveAttribute('data-auto-scrolled', 'true');
});
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story creation | John (PM) |
| 2025-01-28 | 2.0 | VALIDATION ENHANCEMENT: Added comprehensive technical implementation, WebSocket architecture, and extensive testing framework | Sarah (PO) |

## Dev Agent Record
_(This section is owned by dev-agent and can only be modified by dev-agent)_

## QA Results
_(This section is owned by qa-agent and can only be modified by qa-agent)_