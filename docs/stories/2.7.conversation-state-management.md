# Story 2.7: conversation-state-management

## Status
Draft

## Story
**As a** user,
**I want** agent conversation state synchronized with existing dashboard state,
**so that** live debates integrate seamlessly with current signal display and user workflow.

## Acceptance Criteria
1. Conversation state management extends existing dashboard state patterns and context management
2. Real-time agent messages synchronized with existing signal data and market context display
3. Conversation state persists using existing session management and local storage patterns
4. Agent debate state integrates with existing dashboard navigation and routing
5. Conversation history accessible through existing session management and data persistence
6. Real-time state updates maintain existing dashboard performance and responsiveness
7. Agent conversation state respects existing user preferences and customization settings
8. Conversation management integrates with existing error handling and recovery mechanisms
9. Live debate state synchronized across multiple browser tabs using existing state patterns
10. Conversation state cleanup uses existing session lifecycle and resource management

## Tasks / Subtasks
- [ ] Extend dashboard state management (AC: 1, 2)
  - [ ] Extend existing state patterns for conversation data
  - [ ] Synchronize agent messages with signal and market data
- [ ] Implement state persistence (AC: 3, 5)
  - [ ] Use existing session management for conversation state
  - [ ] Make conversation history accessible through existing patterns
- [ ] Integrate with navigation and routing (AC: 4)
  - [ ] Connect agent debate state with dashboard navigation
  - [ ] Ensure routing compatibility with live conversations
- [ ] Maintain performance and preferences (AC: 6, 7)
  - [ ] Keep existing dashboard performance standards
  - [ ] Respect existing user preferences and customization
- [ ] Add error handling and cleanup (AC: 8, 9, 10)
  - [ ] Integrate with existing error handling mechanisms
  - [ ] Synchronize state across browser tabs
  - [ ] Use existing session lifecycle for cleanup

## Dev Notes

### **CRITICAL IMPLEMENTATION BLOCKERS**
⚠️ **STORY DEPENDENCY**: Requires Epic 1.8 (Multi-Agent Conversation) completion for conversation data structures
- Epic 1.8: Multi-agent conversation orchestrator - **STATUS: Approved** ✅
- Epic 2.6: Live conversation display - **DEPENDENCY**: Must complete for UI state integration

### Relevant Source Tree Info
- **VERIFIED**: `/src/stores/` - Existing Zustand dashboard state patterns ✅
- **VERIFIED**: `/src/lib/session/` - Session management and local storage systems ✅
- **VERIFIED**: `/src/app/` - Dashboard navigation and routing infrastructure ✅
- **VERIFIED**: `/src/lib/preferences/` - User preferences and customization settings ✅

### State Management Technical Implementation
```typescript
// apps/web/src/stores/conversationStore.ts
import { create } from 'zustand';
import { persist, subscribeWithSelector } from 'zustand/middleware';
import { AgentMessage, ConversationStatus, ConversationResult } from '@/types/agents';

interface ConversationState {
  // Active conversation state
  activeConversation: {
    sessionId: string | null;
    status: ConversationStatus;
    messages: AgentMessage[];
    participants: string[];
    startedAt: Date | null;
    completedAt: Date | null;
  };

  // Conversation history
  conversationHistory: ConversationResult[];

  // UI state
  isDisplayVisible: boolean;
  isStreaming: boolean;
  autoScroll: boolean;

  // Actions
  startConversation: (sessionId: string, participants: string[]) => void;
  addMessage: (message: AgentMessage) => void;
  updateStatus: (status: ConversationStatus) => void;
  completeConversation: (result: ConversationResult) => void;
  toggleDisplay: () => void;
  clearActiveConversation: () => void;

  // History management
  loadConversationHistory: () => Promise<void>;
  getConversationById: (sessionId: string) => ConversationResult | undefined;
}

export const useConversationStore = create<ConversationState>()(
  subscribeWithSelector(
    persist(
      (set, get) => ({
        // Initial state
        activeConversation: {
          sessionId: null,
          status: 'idle',
          messages: [],
          participants: [],
          startedAt: null,
          completedAt: null,
        },
        conversationHistory: [],
        isDisplayVisible: false,
        isStreaming: false,
        autoScroll: true,

        // Actions
        startConversation: (sessionId, participants) => {
          set({
            activeConversation: {
              sessionId,
              status: 'initializing',
              messages: [],
              participants,
              startedAt: new Date(),
              completedAt: null,
            },
            isStreaming: true,
            isDisplayVisible: true,
          });
        },

        addMessage: (message) => {
          set((state) => ({
            activeConversation: {
              ...state.activeConversation,
              messages: [...state.activeConversation.messages, message],
              status: 'active',
            },
          }));
        },

        updateStatus: (status) => {
          set((state) => ({
            activeConversation: {
              ...state.activeConversation,
              status,
            },
            isStreaming: status === 'active',
          }));
        },

        completeConversation: (result) => {
          set((state) => ({
            activeConversation: {
              ...state.activeConversation,
              status: 'completed',
              completedAt: new Date(),
            },
            conversationHistory: [result, ...state.conversationHistory.slice(0, 49)], // Keep last 50
            isStreaming: false,
          }));
        },

        toggleDisplay: () => {
          set((state) => ({
            isDisplayVisible: !state.isDisplayVisible,
          }));
        },

        clearActiveConversation: () => {
          set({
            activeConversation: {
              sessionId: null,
              status: 'idle',
              messages: [],
              participants: [],
              startedAt: null,
              completedAt: null,
            },
            isStreaming: false,
          });
        },

        loadConversationHistory: async () => {
          try {
            const response = await fetch('/api/conversations/history');
            const history = await response.json();
            set({ conversationHistory: history });
          } catch (error) {
            console.error('Failed to load conversation history:', error);
          }
        },

        getConversationById: (sessionId) => {
          return get().conversationHistory.find(conv => conv.sessionId === sessionId);
        },
      }),
      {
        name: 'conversation-state',
        partialize: (state) => ({
          conversationHistory: state.conversationHistory,
          isDisplayVisible: state.isDisplayVisible,
          autoScroll: state.autoScroll,
        }),
      }
    )
  )
);
```

### Integration with Existing Dashboard State
```typescript
// apps/web/src/stores/dashboardStore.ts (Enhancement)
import { create } from 'zustand';
import { useConversationStore } from './conversationStore';

// Extend existing dashboard store
interface DashboardState {
  // ... existing dashboard state

  // Conversation integration
  conversationSidebarOpen: boolean;
  conversationMode: 'overlay' | 'sidebar' | 'fullscreen';

  // Actions
  toggleConversationSidebar: () => void;
  setConversationMode: (mode: 'overlay' | 'sidebar' | 'fullscreen') => void;
}

// Cross-store synchronization
useConversationStore.subscribe(
  (state) => state.activeConversation.status,
  (status) => {
    // Auto-open conversation display when conversation starts
    if (status === 'initializing') {
      useDashboardStore.getState().setConversationMode('sidebar');
    }
  }
);
```

### Session Persistence Integration
```typescript
// apps/web/src/lib/session/conversationSession.ts
import { ConversationResult } from '@/types/agents';

export class ConversationSessionManager {
  private readonly SESSION_KEY = 'gayed-conversation-sessions';
  private readonly MAX_SESSIONS = 50;

  // Save conversation to persistent storage
  async saveConversation(conversation: ConversationResult): Promise<void> {
    try {
      const existing = this.getStoredSessions();
      const updated = [conversation, ...existing.slice(0, this.MAX_SESSIONS - 1)];

      localStorage.setItem(this.SESSION_KEY, JSON.stringify(updated));

      // Also save to database for cross-device sync
      await fetch('/api/conversations/save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(conversation),
      });
    } catch (error) {
      console.error('Failed to save conversation:', error);
    }
  }

  // Load conversations from storage
  getStoredSessions(): ConversationResult[] {
    try {
      const stored = localStorage.getItem(this.SESSION_KEY);
      return stored ? JSON.parse(stored) : [];
    } catch {
      return [];
    }
  }

  // Cross-tab synchronization
  setupCrossTabSync(): void {
    window.addEventListener('storage', (event) => {
      if (event.key === this.SESSION_KEY && event.newValue) {
        const updatedSessions = JSON.parse(event.newValue);
        useConversationStore.getState().conversationHistory = updatedSessions;
      }
    });
  }

  // Cleanup old sessions
  cleanupOldSessions(): void {
    const sessions = this.getStoredSessions();
    const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

    const recent = sessions.filter(session =>
      new Date(session.completedAt) > oneWeekAgo
    );

    localStorage.setItem(this.SESSION_KEY, JSON.stringify(recent));
  }
}
```

### Real-time State Synchronization
```typescript
// apps/web/src/hooks/useConversationSync.ts
import { useEffect } from 'react';
import { useConversationStore } from '@/stores/conversationStore';
import { useWebSocket } from '@/hooks/useWebSocket';

export function useConversationSync(sessionId: string | null) {
  const { socket } = useWebSocket('/api/conversations/sync');
  const { addMessage, updateStatus, completeConversation } = useConversationStore();

  useEffect(() => {
    if (!socket || !sessionId) return;

    // Sync conversation state across tabs/devices
    socket.emit('join-conversation', sessionId);

    socket.on('conversation-update', (update) => {
      switch (update.type) {
        case 'message':
          addMessage(update.message);
          break;
        case 'status':
          updateStatus(update.status);
          break;
        case 'complete':
          completeConversation(update.result);
          break;
      }
    });

    return () => {
      socket.emit('leave-conversation', sessionId);
      socket.off('conversation-update');
    };
  }, [socket, sessionId, addMessage, updateStatus, completeConversation]);
}
```

### Performance Optimization
```typescript
// apps/web/src/lib/performance/conversationOptimization.ts

// Message virtualization for large conversations
export function useVirtualizedMessages(messages: AgentMessage[], containerHeight: number) {
  const itemHeight = 120; // Average message height
  const visibleItems = Math.ceil(containerHeight / itemHeight) + 2; // Buffer

  return useMemo(() => {
    if (messages.length <= visibleItems) return messages;

    // Show recent messages + some history
    const recentCount = Math.floor(visibleItems * 0.7);
    const historyCount = visibleItems - recentCount;

    return [
      ...messages.slice(0, historyCount),
      { type: 'gap', count: messages.length - historyCount - recentCount },
      ...messages.slice(-recentCount)
    ];
  }, [messages, visibleItems]);
}

// State cleanup for memory management
export function useStateCleanup() {
  useEffect(() => {
    const cleanup = () => {
      const store = useConversationStore.getState();

      // Clear old messages from active conversation
      if (store.activeConversation.messages.length > 100) {
        store.activeConversation.messages = store.activeConversation.messages.slice(-50);
      }

      // Clean up conversation history
      if (store.conversationHistory.length > 50) {
        store.conversationHistory = store.conversationHistory.slice(0, 50);
      }
    };

    const interval = setInterval(cleanup, 5 * 60 * 1000); // Every 5 minutes
    return () => clearInterval(interval);
  }, []);
}
```

### State Management Approach
- **Zustand-based**: Extends existing dashboard store patterns
- **Persistent**: Local storage + database for cross-device sync
- **Real-time**: WebSocket integration for live state updates
- **Optimized**: Virtual scrolling and memory management for performance
- **Cross-tab**: Synchronized state across multiple browser tabs

### Key Constraints
- Maximum 50 conversations in history to prevent memory issues
- Real-time updates throttled to 100ms to maintain dashboard performance
- Cross-tab synchronization limited to conversation status and new messages
- Automatic cleanup of conversations older than 7 days
- State persistence respects existing user privacy preferences

### Testing
**Comprehensive State Management Testing Framework:**

**Unit Tests - Zustand Store:**
```typescript
// apps/web/__tests__/stores/conversationStore.test.ts
import { act, renderHook } from '@testing-library/react';
import { useConversationStore } from '@/stores/conversationStore';

describe('ConversationStore', () => {
  beforeEach(() => {
    useConversationStore.getState().clearActiveConversation();
  });

  test('starts conversation with proper state initialization', () => {
    const { result } = renderHook(() => useConversationStore());

    act(() => {
      result.current.startConversation('session-123', ['FinancialAnalyst', 'MarketContext']);
    });

    expect(result.current.activeConversation.sessionId).toBe('session-123');
    expect(result.current.activeConversation.status).toBe('initializing');
    expect(result.current.isStreaming).toBe(true);
    expect(result.current.isDisplayVisible).toBe(true);
  });

  test('adds messages and updates conversation state', () => {
    const { result } = renderHook(() => useConversationStore());

    act(() => {
      result.current.startConversation('session-123', ['FinancialAnalyst']);
    });

    const testMessage = {
      agent: 'FinancialAnalyst',
      content: 'Test analysis',
      timestamp: Date.now(),
      confidence: 0.8
    };

    act(() => {
      result.current.addMessage(testMessage);
    });

    expect(result.current.activeConversation.messages).toHaveLength(1);
    expect(result.current.activeConversation.messages[0]).toEqual(testMessage);
    expect(result.current.activeConversation.status).toBe('active');
  });

  test('completes conversation and updates history', () => {
    const { result } = renderHook(() => useConversationStore());

    const conversationResult = {
      sessionId: 'session-123',
      messages: [],
      consensus: 'Test consensus',
      completedAt: new Date().toISOString()
    };

    act(() => {
      result.current.completeConversation(conversationResult);
    });

    expect(result.current.conversationHistory).toHaveLength(1);
    expect(result.current.conversationHistory[0]).toEqual(conversationResult);
    expect(result.current.isStreaming).toBe(false);
  });
});
```

**Integration Tests - Cross-Store Synchronization:**
```typescript
// apps/web/__tests__/integration/storeSync.test.ts
import { renderHook, act } from '@testing-library/react';
import { useConversationStore } from '@/stores/conversationStore';
import { useDashboardStore } from '@/stores/dashboardStore';

describe('Store Synchronization', () => {
  test('conversation start triggers dashboard mode change', () => {
    const { result: conversationResult } = renderHook(() => useConversationStore());
    const { result: dashboardResult } = renderHook(() => useDashboardStore());

    act(() => {
      conversationResult.current.startConversation('test-session', ['FinancialAnalyst']);
    });

    // Should trigger dashboard conversation mode
    expect(dashboardResult.current.conversationMode).toBe('sidebar');
  });
});
```

**Performance Tests:**
```typescript
// apps/web/__tests__/performance/conversationPerformance.test.ts
import { performance } from 'perf_hooks';
import { useConversationStore } from '@/stores/conversationStore';

describe('Conversation State Performance', () => {
  test('handles 1000 messages without performance degradation', () => {
    const store = useConversationStore.getState();
    store.startConversation('perf-test', ['FinancialAnalyst']);

    const startTime = performance.now();

    // Add 1000 messages
    for (let i = 0; i < 1000; i++) {
      store.addMessage({
        agent: 'FinancialAnalyst',
        content: `Message ${i}`,
        timestamp: Date.now() + i,
      });
    }

    const endTime = performance.now();
    const duration = endTime - startTime;

    // Should complete within 100ms
    expect(duration).toBeLessThan(100);

    // Memory management should limit messages
    expect(store.activeConversation.messages.length).toBeLessThanOrEqual(50);
  });

  test('state persistence operations are performant', async () => {
    const sessionManager = new ConversationSessionManager();
    const testConversations = Array.from({ length: 50 }, (_, i) => ({
      sessionId: `session-${i}`,
      messages: [],
      consensus: `Consensus ${i}`,
      completedAt: new Date().toISOString()
    }));

    const startTime = performance.now();

    for (const conversation of testConversations) {
      await sessionManager.saveConversation(conversation);
    }

    const endTime = performance.now();
    const avgTime = (endTime - startTime) / testConversations.length;

    // Each save operation should average under 50ms
    expect(avgTime).toBeLessThan(50);
  });
});
```

**Multi-tab Synchronization Tests:**
```typescript
// apps/web/__tests__/integration/crossTabSync.test.ts
describe('Cross-tab State Synchronization', () => {
  test('conversation state syncs across browser tabs', () => {
    // Simulate multiple tab environments
    const tab1Store = useConversationStore.getState();
    const tab2Store = useConversationStore.getState();

    // Start conversation in tab 1
    tab1Store.startConversation('sync-test', ['FinancialAnalyst']);

    // Simulate localStorage change event (cross-tab communication)
    const storageEvent = new StorageEvent('storage', {
      key: 'conversation-state',
      newValue: JSON.stringify({
        conversationHistory: [{ sessionId: 'sync-test', status: 'active' }]
      })
    });

    window.dispatchEvent(storageEvent);

    // Tab 2 should receive the update
    expect(tab2Store.conversationHistory).toContainEqual(
      expect.objectContaining({ sessionId: 'sync-test' })
    );
  });
});
```

**Session Persistence Tests:**
```typescript
// apps/web/__tests__/persistence/sessionPersistence.test.ts
describe('Session Persistence', () => {
  test('saves and loads conversation history correctly', async () => {
    const sessionManager = new ConversationSessionManager();

    const testConversation = {
      sessionId: 'persist-test',
      messages: [{ agent: 'FinancialAnalyst', content: 'Test message' }],
      consensus: 'Test consensus',
      completedAt: new Date().toISOString()
    };

    await sessionManager.saveConversation(testConversation);
    const loaded = sessionManager.getStoredSessions();

    expect(loaded).toContainEqual(testConversation);
  });

  test('cleans up old sessions automatically', () => {
    const sessionManager = new ConversationSessionManager();

    // Add old conversation (8 days ago)
    const oldConversation = {
      sessionId: 'old-session',
      completedAt: new Date(Date.now() - 8 * 24 * 60 * 60 * 1000).toISOString()
    };

    localStorage.setItem('gayed-conversation-sessions', JSON.stringify([oldConversation]));

    sessionManager.cleanupOldSessions();

    const remaining = sessionManager.getStoredSessions();
    expect(remaining).not.toContainEqual(oldConversation);
  });
});
```

**Error Handling & Recovery Tests:**
```typescript
// apps/web/__tests__/error/stateErrorHandling.test.ts
describe('State Error Handling', () => {
  test('handles corrupted localStorage gracefully', () => {
    // Corrupt localStorage data
    localStorage.setItem('conversation-state', 'invalid-json');

    const sessionManager = new ConversationSessionManager();
    const sessions = sessionManager.getStoredSessions();

    // Should return empty array instead of throwing
    expect(sessions).toEqual([]);
  });

  test('recovers from network failures during persistence', async () => {
    // Mock network failure
    global.fetch = jest.fn().mockRejectedValue(new Error('Network error'));

    const sessionManager = new ConversationSessionManager();
    const testConversation = { sessionId: 'network-test' };

    // Should not throw, should handle gracefully
    await expect(sessionManager.saveConversation(testConversation)).resolves.not.toThrow();

    // Should still save to localStorage as fallback
    const localSessions = sessionManager.getStoredSessions();
    expect(localSessions).toContainEqual(testConversation);
  });
});
```

**Memory Management Tests:**
```typescript
// apps/web/__tests__/performance/memoryManagement.test.ts
describe('Memory Management', () => {
  test('conversation history is limited to prevent memory leaks', () => {
    const store = useConversationStore.getState();

    // Add 60 conversations (over the 50 limit)
    for (let i = 0; i < 60; i++) {
      store.completeConversation({
        sessionId: `session-${i}`,
        messages: [],
        consensus: `Consensus ${i}`,
        completedAt: new Date().toISOString()
      });
    }

    // Should only keep 50 most recent
    expect(store.conversationHistory.length).toBe(50);
  });
});
```

**Performance Benchmarks:**
- State updates: <10ms per message addition
- Cross-tab sync: <50ms latency
- Session persistence: <100ms for 50 conversations
- Memory usage: <100MB for 50 active conversations
- Cleanup operations: <20ms for 1000+ conversation cleanup

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-21 | 1.0 | Initial story creation | John (PM) |
| 2025-01-28 | 2.0 | VALIDATION ENHANCEMENT: Added comprehensive Zustand store implementation, cross-tab sync, session persistence, and performance optimizations | Sarah (PO) |

## Dev Agent Record
_(This section is owned by dev-agent and can only be modified by dev-agent)_

## QA Results
_(This section is owned by qa-agent and can only be modified by qa-agent)_