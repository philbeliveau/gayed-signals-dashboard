# Story 2.8: autogen-websocket-integration-bridge

## Status
Ready for Implementation

## Story
**As a** financial professional,
**I want** AutoGen agent conversations to stream live through the WebSocket infrastructure,
**so that** I can watch real-time agent debates instead of demo mode conversations.

## Epic Context
This story completes **Epic 3: "Real-Time WebSocket Debate Streaming"** by creating the integration bridge between the completed AutoGen agents and WebSocket infrastructure. Currently the system runs in demo mode because this critical bridge doesn't exist.

## Dependencies
- ✅ **Story 1.2**: WebSocket infrastructure (COMPLETED) - Generic event system ready
- ✅ **Story 2.6**: Live Conversation Display (COMPLETED) - Frontend UI ready
- ✅ **Stories 1.5-1.7**: AutoGen agents (COMPLETED) - Financial, Market Context, Risk agents ready
- ✅ **Story 1.8**: Multi-Agent Conversation (COMPLETED) - Conversation orchestrator ready

## Acceptance Criteria
1. **AutoGen-WebSocket Bridge**: Create backend bridge connecting AutoGen conversation events to WebSocket infrastructure
2. **Real-Time Agent Streaming**: Agent messages from AutoGen conversations stream live to WebSocket clients
3. **Conversation State Sync**: AutoGen conversation state (initializing, active, completed) synchronized with WebSocket status
4. **Event Translation**: Convert AutoGen conversation events to WebSocket-compatible message format
5. **Session Management**: Link AutoGen conversation sessions with WebSocket connection sessions
6. **Performance Optimization**: Bridge handles concurrent conversations without degrading WebSocket performance
7. **Error Handling**: Graceful handling when AutoGen backend fails with fallback to demo mode
8. **Demo Mode Replacement**: Replace existing demo mode with real AutoGen conversation streaming
9. **Authentication Bridge**: Maintain Clerk authentication across AutoGen and WebSocket connections
10. **Integration Testing**: End-to-end validation of AutoGen → WebSocket → Frontend conversation flow

## Tasks / Subtasks
- [ ] Implement backend WebSocket handler (AC: 1, 4)
  - [ ] Create `autogen-websocket-bridge.py` to connect AutoGen events to WebSocket
  - [ ] Implement event translation from AutoGen format to WebSocket format
  - [ ] Handle AutoGen conversation lifecycle events (start, message, complete, error)
- [ ] Build conversation streaming endpoint (AC: 2, 5)
  - [ ] Create `/api/conversations/[id]/stream` endpoint for real-time streaming
  - [ ] Link AutoGen conversation sessions with WebSocket sessions
  - [ ] Implement session cleanup and resource management
- [ ] Synchronize conversation state (AC: 3, 6)
  - [ ] Map AutoGen conversation states to WebSocket status indicators
  - [ ] Handle concurrent conversation management without performance degradation
  - [ ] Implement proper connection pooling for multiple users
- [ ] Replace demo mode functionality (AC: 7, 8)
  - [ ] Update conversation starter to use real AutoGen backend
  - [ ] Implement fallback to demo mode when AutoGen backend unavailable
  - [ ] Remove demo mode as default, use only as fallback
- [ ] Integrate authentication and testing (AC: 9, 10)
  - [ ] Ensure Clerk authentication works across AutoGen and WebSocket connections
  - [ ] Create end-to-end tests validating complete conversation flow
  - [ ] Test error scenarios and fallback mechanisms

## Dev Notes

### **CRITICAL IMPLEMENTATION BLOCKERS**
⚠️ **DEPENDENCY VALIDATION**: All prerequisite stories completed - ready for implementation
- Story 1.2: WebSocket infrastructure - **STATUS: Ready for Done** ✅
- Story 2.6: Live Conversation Display - **STATUS: Ready for Review** ✅
- Story 1.8: Multi-Agent Conversation - **STATUS: Approved** ✅
- Stories 1.5-1.7: AutoGen agents - **STATUS: Completed** ✅

### Relevant Source Tree Info
- **VERIFIED**: `/src/lib/websocket/` - WebSocket infrastructure ready for integration ✅
- **VERIFIED**: `/src/components/agents/LiveConversationDisplay.tsx` - Frontend UI ready ✅
- **VERIFIED**: `/apps/backend/api/v1/conversations.py` - AutoGen conversation API ready ✅
- **VERIFIED**: `/src/domains/ai-agents/conversation/orchestrator.ts` - Conversation orchestrator ready ✅

### AutoGen-WebSocket Bridge Architecture

#### Backend Bridge Implementation
```python
# apps/backend/api/websocket/autogen_bridge.py
import asyncio
import json
from typing import Dict, Any, Optional
from fastapi import WebSocket, WebSocketDisconnect, Depends
from sqlalchemy.ext.asyncio import AsyncSession

from ..v1.conversations import ConversationOrchestrator
from ...core.database import get_db_session
from ...core.websocket import WebSocketManager

class AutoGenWebSocketBridge:
    """Bridge connecting AutoGen conversations to WebSocket infrastructure"""

    def __init__(self):
        self.websocket_manager = WebSocketManager()
        self.active_conversations: Dict[str, ConversationOrchestrator] = {}
        self.conversation_websockets: Dict[str, list] = {}

    async def start_conversation_stream(
        self,
        websocket: WebSocket,
        conversation_id: str,
        content: str,
        content_type: str,
        user_id: str,
        db: AsyncSession = Depends(get_db_session)
    ):
        """Start AutoGen conversation with real-time WebSocket streaming"""
        try:
            # Accept WebSocket connection
            await websocket.accept()

            # Register WebSocket for this conversation
            if conversation_id not in self.conversation_websockets:
                self.conversation_websockets[conversation_id] = []
            self.conversation_websockets[conversation_id].append(websocket)

            # Send initial status
            await self.send_conversation_status(conversation_id, "initializing")

            # Create AutoGen conversation orchestrator
            orchestrator = ConversationOrchestrator(
                conversation_id=conversation_id,
                user_id=user_id,
                db=db
            )

            self.active_conversations[conversation_id] = orchestrator

            # Set up event handlers for AutoGen conversation
            orchestrator.on_agent_message = lambda msg: self.handle_agent_message(conversation_id, msg)
            orchestrator.on_status_change = lambda status: self.handle_status_change(conversation_id, status)
            orchestrator.on_conversation_complete = lambda result: self.handle_conversation_complete(conversation_id, result)
            orchestrator.on_error = lambda error: self.handle_conversation_error(conversation_id, error)

            # Start AutoGen conversation
            await orchestrator.start_conversation(content, content_type)

            # Keep WebSocket alive and handle messages
            while True:
                try:
                    # Wait for WebSocket messages or conversation completion
                    data = await websocket.receive_text()
                    message = json.loads(data)

                    # Handle client commands (pause, resume, etc.)
                    if message.get("type") == "control":
                        await self.handle_client_control(conversation_id, message)

                except WebSocketDisconnect:
                    await self.cleanup_conversation(conversation_id, websocket)
                    break

        except Exception as e:
            await self.handle_conversation_error(conversation_id, str(e))

    async def handle_agent_message(self, conversation_id: str, message: Dict[str, Any]):
        """Convert AutoGen agent message to WebSocket format and broadcast"""
        websocket_message = {
            "type": "agent_message",
            "data": {
                "agent": message["agent"],
                "content": message["content"],
                "timestamp": message["timestamp"],
                "confidence": message.get("confidence"),
                "conversation_id": conversation_id
            }
        }

        await self.broadcast_to_conversation(conversation_id, websocket_message)

    async def handle_status_change(self, conversation_id: str, status: str):
        """Handle AutoGen conversation status changes"""
        await self.send_conversation_status(conversation_id, status)

    async def handle_conversation_complete(self, conversation_id: str, result: Dict[str, Any]):
        """Handle AutoGen conversation completion"""
        websocket_message = {
            "type": "conversation_complete",
            "data": {
                "conversation_id": conversation_id,
                "consensus": result.get("consensus"),
                "summary": result.get("summary"),
                "timestamp": result.get("timestamp")
            }
        }

        await self.broadcast_to_conversation(conversation_id, websocket_message)
        await self.send_conversation_status(conversation_id, "completed")

        # Cleanup after completion
        await self.cleanup_conversation(conversation_id)

    async def handle_conversation_error(self, conversation_id: str, error: str):
        """Handle AutoGen conversation errors with fallback to demo mode"""
        error_message = {
            "type": "conversation_error",
            "data": {
                "conversation_id": conversation_id,
                "error": error,
                "fallback_mode": "demo"
            }
        }

        await self.broadcast_to_conversation(conversation_id, error_message)
        await self.send_conversation_status(conversation_id, "error")

        # Fallback to demo mode
        await self.start_demo_mode_fallback(conversation_id)

    async def send_conversation_status(self, conversation_id: str, status: str):
        """Send conversation status update to WebSocket clients"""
        status_message = {
            "type": "conversation_status",
            "data": {
                "conversation_id": conversation_id,
                "status": status,
                "timestamp": asyncio.get_event_loop().time()
            }
        }

        await self.broadcast_to_conversation(conversation_id, status_message)

    async def broadcast_to_conversation(self, conversation_id: str, message: Dict[str, Any]):
        """Broadcast message to all WebSockets connected to conversation"""
        if conversation_id not in self.conversation_websockets:
            return

        websockets = self.conversation_websockets[conversation_id].copy()
        for websocket in websockets:
            try:
                await websocket.send_text(json.dumps(message))
            except Exception:
                # Remove disconnected websocket
                self.conversation_websockets[conversation_id].remove(websocket)

    async def cleanup_conversation(self, conversation_id: str, websocket: Optional[WebSocket] = None):
        """Clean up conversation resources"""
        if websocket and conversation_id in self.conversation_websockets:
            try:
                self.conversation_websockets[conversation_id].remove(websocket)
            except ValueError:
                pass

        # If no more websockets, cleanup conversation
        if not self.conversation_websockets.get(conversation_id):
            if conversation_id in self.active_conversations:
                await self.active_conversations[conversation_id].cleanup()
                del self.active_conversations[conversation_id]

            if conversation_id in self.conversation_websockets:
                del self.conversation_websockets[conversation_id]

    async def start_demo_mode_fallback(self, conversation_id: str):
        """Fallback to demo mode when AutoGen backend fails"""
        # Import demo mode logic from existing implementation
        from ...demo.conversation_demo import ConversationDemo

        demo = ConversationDemo(conversation_id)
        demo.on_message = lambda msg: self.handle_agent_message(conversation_id, msg)
        demo.on_complete = lambda result: self.handle_conversation_complete(conversation_id, result)

        await demo.start()
```

#### WebSocket Endpoint Integration
```typescript
// apps/web/src/app/api/conversations/[id]/stream/route.ts
import { NextRequest } from 'next/server';
import { WebSocket } from 'ws';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const conversationId = params.id;

  if (request.headers.get('upgrade') !== 'websocket') {
    return new Response('Expected Upgrade: websocket', { status: 426 });
  }

  // Upgrade to WebSocket connection
  const { socket, response } = await upgradeWebSocket(request);

  socket.onopen = () => {
    console.log(`WebSocket opened for conversation ${conversationId}`);
  };

  socket.onmessage = async (event) => {
    try {
      const message = JSON.parse(event.data);

      if (message.type === 'start_conversation') {
        // Forward to AutoGen backend bridge
        await startAutoGenConversation(conversationId, message.data, socket);
      } else if (message.type === 'control') {
        // Handle conversation control commands
        await handleConversationControl(conversationId, message.data);
      }
    } catch (error) {
      console.error('WebSocket message error:', error);
    }
  };

  socket.onclose = () => {
    console.log(`WebSocket closed for conversation ${conversationId}`);
    // Cleanup conversation resources
    cleanupConversation(conversationId);
  };

  return response;
}

async function startAutoGenConversation(
  conversationId: string,
  data: any,
  socket: WebSocket
) {
  try {
    // Connect to AutoGen backend via HTTP/WebSocket bridge
    const response = await fetch(`${process.env.BACKEND_URL}/api/v1/conversations/${conversationId}/start`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${data.authToken}`
      },
      body: JSON.stringify({
        content: data.content,
        content_type: data.contentType,
        user_id: data.userId
      })
    });

    if (!response.ok) {
      throw new Error(`AutoGen backend error: ${response.statusText}`);
    }

    // Start streaming from AutoGen backend
    const backendWs = new WebSocket(`${process.env.BACKEND_WS_URL}/ws/conversations/${conversationId}`);

    backendWs.onmessage = (event) => {
      // Forward messages from AutoGen to frontend WebSocket
      socket.send(event.data);
    };

    backendWs.onerror = () => {
      // Fallback to demo mode on backend failure
      socket.send(JSON.stringify({
        type: 'fallback_mode',
        data: { mode: 'demo', reason: 'backend_unavailable' }
      }));
      startDemoMode(conversationId, socket);
    };

  } catch (error) {
    console.error('AutoGen connection failed:', error);
    // Fallback to demo mode
    startDemoMode(conversationId, socket);
  }
}
```

#### Frontend Integration Updates
```typescript
// apps/web/src/components/agents/LiveConversationDisplay.tsx (Updates)

// Replace demo mode with real AutoGen streaming
export function LiveConversationDisplay({
  sessionId,
  onConversationComplete
}: LiveConversationDisplayProps) {
  const [messages, setMessages] = useState<AgentMessage[]>([]);
  const [status, setStatus] = useState<ConversationStatus>('initializing');
  const [isUsingDemo, setIsUsingDemo] = useState(false);

  // WebSocket connection for REAL AutoGen conversations
  const { socket, isConnected } = useWebSocket(`/api/conversations/${sessionId}/stream`);

  useEffect(() => {
    if (!socket) return;

    // Handle real AutoGen agent messages
    socket.on('agent_message', (message: AgentMessage) => {
      setMessages(prev => [...prev, message]);
      scrollToBottom();
    });

    // Handle AutoGen conversation status
    socket.on('conversation_status', (newStatus: ConversationStatus) => {
      setStatus(newStatus);
    });

    // Handle fallback to demo mode
    socket.on('fallback_mode', (data: { mode: string; reason: string }) => {
      setIsUsingDemo(true);
      console.warn(`Falling back to ${data.mode} mode: ${data.reason}`);
      // Continue with demo mode for user experience
    });

    // Handle conversation completion
    socket.on('conversation_complete', (result: ConversationResult) => {
      setStatus('completed');
      onConversationComplete?.(result);
    });

    return () => {
      socket.off('agent_message');
      socket.off('conversation_status');
      socket.off('fallback_mode');
      socket.off('conversation_complete');
    };
  }, [socket, onConversationComplete]);

  // Start REAL AutoGen conversation instead of demo
  const startConversation = async (content: string, contentType: string) => {
    if (!socket) return;

    socket.emit('start_conversation', {
      content,
      contentType,
      userId: user.id,
      authToken: await getToken()
    });
  };

  return (
    <Card className="flex flex-col h-[600px] max-h-[600px]">
      <CardHeader className="flex-shrink-0 pb-3">
        <div className="flex items-center justify-between">
          <h3 className="text-lg font-semibold">
            {isUsingDemo ? 'Demo: ' : 'Live '}Agent Conversation
          </h3>
          <ConversationStatusBadge
            status={status}
            isConnected={isConnected}
            isDemoMode={isUsingDemo}
          />
        </div>
      </CardHeader>

      {/* Rest of component remains the same */}
    </Card>
  );
}
```

### Performance & Integration Specifications
- **Real-Time Latency**: <500ms from AutoGen agent message to WebSocket delivery
- **Concurrent Conversations**: Support 50+ simultaneous conversations per server instance
- **Fallback Performance**: <2 seconds to detect AutoGen failure and switch to demo mode
- **Memory Management**: Limit conversation history and properly cleanup resources
- **Authentication**: Maintain Clerk session validation across all connections

### Event Flow Architecture
```
Content Input → AutoGen Conversation Orchestrator → Agent Messages
     ↓                      ↓                           ↓
WebSocket Bridge ← Event Translation ← Agent Events ← Agent Processing
     ↓                      ↓                           ↓
WebSocket Stream → Frontend Display → Real-time UI Updates
```

### Key Constraints
- Must maintain backward compatibility with existing demo mode as fallback
- Cannot break existing WebSocket infrastructure or LiveConversationDisplay component
- AutoGen backend failures must gracefully fallback without user interruption
- Authentication must work seamlessly across AutoGen, WebSocket, and frontend
- Performance cannot degrade WebSocket infrastructure for other services

### Testing
**Comprehensive Testing Framework:**

**Unit Tests:**
```typescript
// apps/web/__tests__/integration/autoGenWebSocketBridge.test.ts
import { AutoGenWebSocketBridge } from '@/lib/websocket/autogen-bridge';
import { mockAutoGenOrchestrator } from '@/mocks/autogen';

describe('AutoGen-WebSocket Bridge', () => {
  test('translates AutoGen events to WebSocket format', async () => {
    const bridge = new AutoGenWebSocketBridge();
    const mockWebSocket = new MockWebSocket();

    // Simulate AutoGen agent message
    const agentMessage = {
      agent: 'FinancialAnalyst',
      content: 'Market shows bullish signals',
      timestamp: Date.now(),
      confidence: 0.85
    };

    await bridge.handleAgentMessage('test-session', agentMessage);

    expect(mockWebSocket.sentMessages).toContainEqual({
      type: 'agent_message',
      data: expect.objectContaining({
        agent: 'FinancialAnalyst',
        content: 'Market shows bullish signals',
        confidence: 0.85
      })
    });
  });

  test('handles AutoGen backend failure with demo fallback', async () => {
    const bridge = new AutoGenWebSocketBridge();
    const mockWebSocket = new MockWebSocket();

    // Simulate AutoGen failure
    await bridge.handleConversationError('test-session', 'Backend unavailable');

    expect(mockWebSocket.sentMessages).toContainEqual({
      type: 'conversation_error',
      data: expect.objectContaining({
        fallback_mode: 'demo'
      })
    });
  });
});
```

**Integration Tests:**
- End-to-end conversation flow: Content → AutoGen → WebSocket → Frontend
- Authentication flow across all services
- Fallback mechanism when AutoGen backend unavailable
- Concurrent conversation handling without performance degradation

**Performance Tests:**
- AutoGen message translation latency (<500ms)
- Concurrent conversation capacity (50+ conversations)
- Memory usage with extended conversations
- WebSocket connection pooling efficiency

**Error Handling Tests:**
- AutoGen backend failure scenarios
- WebSocket disconnection during active conversation
- Authentication token expiration handling
- Network timeout and retry mechanisms

**End-to-End Tests:**
```typescript
// apps/web/e2e/real-autogen-conversation.spec.ts
import { test, expect } from '@playwright/test';

test('complete AutoGen conversation flow', async ({ page }) => {
  await page.goto('/dashboard');

  // Start real AutoGen conversation
  await page.fill('[data-testid="content-input"]', 'Analyze current market conditions');
  await page.click('[data-testid="start-conversation"]');

  // Wait for AutoGen initialization
  await expect(page.locator('[data-testid="conversation-status"]')).toHaveText('Initializing');

  // Verify real agent messages appear
  await expect(page.locator('[data-testid="agent-message"]').first()).toBeVisible({ timeout: 10000 });

  // Verify agent sequence (Financial → Market Context → Risk)
  const agentMessages = page.locator('[data-testid="agent-message"]');
  await expect(agentMessages.nth(0)).toContainText('Financial Analyst');
  await expect(agentMessages.nth(1)).toContainText('Market Context');
  await expect(agentMessages.nth(2)).toContainText('Risk Challenger');

  // Verify conversation completion
  await expect(page.locator('[data-testid="conversation-status"]')).toHaveText('Complete', { timeout: 120000 });
});

test('fallback to demo mode on backend failure', async ({ page }) => {
  // Mock AutoGen backend failure
  await page.route('**/api/v1/conversations/**', route => route.abort());

  await page.goto('/dashboard');
  await page.fill('[data-testid="content-input"]', 'Test content');
  await page.click('[data-testid="start-conversation"]');

  // Verify fallback to demo mode
  await expect(page.locator('[data-testid="conversation-display"]')).toContainText('Demo:');
  await expect(page.locator('[data-testid="agent-message"]').first()).toBeVisible();
});
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-30 | 1.0 | Initial story creation for AutoGen-WebSocket integration bridge | Product Manager |

## Dev Agent Record
_(This section is owned by dev-agent and can only be modified by dev-agent)_

### Agent Model Used
[To be completed by implementing dev-agent]

### Implementation Status
**READY FOR IMPLEMENTATION** - All dependencies met, comprehensive technical design provided

### File List
[To be completed by implementing dev-agent]

### Completion Notes
[To be completed by implementing dev-agent]

### Debug Log References
[To be completed by implementing dev-agent]

## QA Results
_(This section is owned by qa-agent and can only be modified by qa-agent)_

### Review Date
[To be completed by qa-agent after implementation]

### Reviewed By
[To be completed by qa-agent]

### Code Quality Assessment
[To be completed by qa-agent after implementation review]

### Gate Status
[To be completed by qa-agent after quality assessment]